
\chapter{Аналитическая часть}
В данной части работы будет рассмотрена модель, по которой будет производиться
визуализация, а также будут определены модель отражения и алгоритм визуализации примитивов.
\section{Модель визуализации примитивов}
В данной части работы происходит формализация объектов сцены и метод их визуализации.

\subsection{Формализация объектов сцены}
\label{sec:obj_formalasation}
На визуализируемой сцене могут находиться следующие объекты.
\begin{enumerate}
	\item  \textbf{Точечный источник света}
	
	Данный источник света излучает свет во всех направлениях, интенсивность света убывает при отдалении от источника.
	Источник характеризуется положением в пространстве и интенсивностью.
	При расчете отражений будет использоваться интенсивность источника, для расчета интенсивности пикселей. Цвет свечения будет описываться через значения RGB.
	
	
	
	\item \textbf{Сфера}
	
	Сфера описывается радиусом и координатами ее центра.
	
	\item  \textbf{Куб}
	
	Для описания куба необходимо несколько параметров.
	\begin{itemize}
		\item Координаты центра.
		\item Размеры куба по каждой из осей.
		\item Угол поворота по каждой из осей.
	\end{itemize}
	\item  \textbf{Конус}
	
	Конус описывается следующими параметрами.
	\begin{itemize}
		\item Половинный угол при вершине осевого сечения конуса.
		\item Высота конуса.
		\item Координаты вершины конуса.
		\item Вектор высоты конуса.
	\end{itemize}
	
	\item  \textbf{Цилиндр}
	
	Цилиндр описывается несколькими параметрами.
	\begin{itemize}
		\item Координаты центра одного основания цилиндра.
		\item Координаты центра другого основания цилиндра.
		\item Радиус цилиндра.
	\end{itemize}
	
	
	\item \textbf{Камера}
	
	Камера описывается несколькими параметрами.
	\begin{itemize}
		\item Координатами своего положения.
		\item Вектором направления взгляда.
		\item <<Правым>> вектором пространства камеры.
		\item <<Верхним>> вектором пространства камеры.
	\end{itemize}
\end{enumerate}

Каждый из примитивов также должен описываться своим цветом в формате RGB, а также
коэффициентами рассеянного, диффузного, зеркального отражения.



\subsection{Определение множества алгоритмов визуализации}
Выделяют простую (локальную) модель освещения, то есть модель освещения в которой учитывается свет, попадающий в рассматриваемую точку только от источника света.
Для получения отражений стоит использовать глобальную модель освещения, в которой также учитывается интенсивность света, отраженного от других поверхностей \cite{Rodgers}.

Приведем пример отражения лучей:

\includeimage
{global_model_light} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Пример трассировки луча} % Подпись рисунка



На рисунке~\ref{img:global_model_light}  призма, загороженная от наблюдателя параллелепипедом, становится видимой из-за отражения в сфере.
Точка 5 видима, так как отражается от обратной стороны параллелепипеда в точке 4 к точке 3 на сфере, а затем к наблюдателю.
Таким образом, при создании глобальной модели освещения, алгоритмы, основанные на удалении невидимых поверхностей не будут давать изображения необходимого качества.
Глобальная модель освещения является частью алгоритмов выделения видимых поверхностей путем трассировки лучей, то есть для визуализации отражений необходимо использовать трассировку лучей \cite{Rodgers}.

\subsection{Визуализация примитивов}
Для визуализации примитивов методом трассировки лучей необходимо определить точку пересечения луча с каждым примитивом сцены или выявить ее отсутствие.

Необходимо ввести уравнение самого луча (\ref{eq:ray_vector_eq}).
\begin{equation} 
	P(t) = \vec{E} +t\vec{D},t \ge 0
	\label{eq:ray_vector_eq}
\end{equation}
Также уравнение~\ref{eq:ray_vector_eq} имеет запись
\begin{equation}
	\label{eq:ray_scalar_eq}
	\begin{aligned}
		x(t) = x_E + t x_D, \\
		y(t) = y_E + t y_D, \\
		z(t) = z_E + t z_D.
	\end{aligned}
\end{equation}
Таким образом луч определяется: точкой обзора --- $\vec{E} = (x_E,y_E,z_E)$ и вектором направления --- $\vec{D} = (x_D,y_D,z_D)$. Значение $t$  определяет направление луча: в случае если $t \ge 0$,
точка на луче находится после точки обзора, иначе - за. Таким образом для поиска ближайшей точки пересечения, необходимо найти наименьшее неотрицательное значение $t$~\cite{Rodgers,primitives_raytracing_equations} .


\textbf{Уравнение сферы}
Сфера с единичным радиусом может быть задана следующим образом:
\begin{equation}
	\vec{P} \cdot \vec{P}=1.
	\label{eq:sphere_eq}
\end{equation}
Для получения условия пересечений достаточно подставить уравнение луча из~(\ref{eq:ray_vector_eq}) в~(\ref{eq:sphere_eq}) и решить полученное уравнение относительно t.
\begin{equation}
	t=\frac{-b\pm\sqrt{b^2-4ac}}{2a}
	\label{eq:sphere_solved}
\end{equation}
После проведенных преобразований будет получена формула~(\ref{eq:sphere_solved}), где:
\begin{enumerate}
	\item $a = \vec{D} \cdot \vec{D};$
	\item $b = 2\vec{E} \cdot \vec{D};$ 
	\item $c = \vec{E} \cdot \vec{E} - 1.$
\end{enumerate}
В случае если вещественные решения уравнения~(\ref{eq:sphere_solved}) отсутствуют, то пересечения луча также отсутствуют, если только одно решение  - существует одно
пересечение и т.~д. Если значение отрицательное то точка пересечения находится за точкой наблюдения и не рассматривается \cite{primitives_raytracing_equations}.

\textbf{Уравнение цилиндра}
Определим $C1$, как первое основание цилиндра, $C2$ --- как второе,
$r$ --- радиус цилиндра. С помощью полученных данных высчитаем ось координат цилиндра $V = extr_b - extr_a$.
Для того чтобы точка $P$ принадлежала цилиндру необходимо, чтобы для нее выполнялось выражение (\ref{eq:cyl}).
\begin{equation}
	\begin{cases}
	A = \vec{C} + \vec{V} \cdot m, \\
	(\vec{P} - \vec{A}) \cdot \vec{V} = 0, \\
	|P-A| = r. 
	\end{cases}
	\label{eq:cyl}
\end{equation}

В системе~(\ref{eq:cyl}), $m$ --- определяет ближайшую точку на оси цилиндра до точки пересечения с лучом. После решения системы уравнений (\ref{eq:cyl})  и подстановки выражения \ref{eq:ray_vector_eq}, будет получено значение $m$ (см.~\ref{eq:cyl_m}).
\begin{equation}
	m = \vec{D} \cdot \vec{V} \cdot t  + (\vec{O} - \vec{C}) \cdot \vec{V}.
	\label{eq:cyl_m}
\end{equation}

После получения значения $m$, возможна запись уравнения (\ref{eq:cyl_ray_eq}).
\begin{equation}
 	|\vec{P}-\vec{C}-\vec{V} \cdot m| = r^{2}
	\label{eq:cyl_ray_eq}
\end{equation}
Введем $\vec{X} = \vec{E} - \vec{C}$.
При решении данного квадратного уравнения относительно $t$ будут получены следующие коэффициенты:
\begin{equation}
	\begin{cases}
		a = \vec{D} \cdot \vec{D} - (\vec{D} \cdot \vec{D}), \\
		\frac{b}{2} = \vec{D} \cdot (\vec{X}) - ((\vec{D} \cdot \vec{V}) \cdot (\vec{X} \cdot \vec{V})), \\
		c = \vec{X} \cdot \vec{X} - (\vec{X} \cdot \vec{V})^{2} - r^{2}.
	\end{cases}
	\label{eq:cyl_solved}
\end{equation}
После получения коэффициентов из системы (\ref{eq:cyl_solved}) и их подстановки в~(\ref{eq:sphere_solved}), будут получены значения $t$ \cite{cyl_inter}.


\textbf{Уравнение конуса}

Определим координаты конуса как $C$, вектор высоты конуса как вектор $V$, 
$\theta$ как половинный угол при вершине осевого сечения конуса. Таким образом
каждая точка $X$ на конусе, может определяться с помощью формулы (\ref{eq:cone_form}).
\begin{equation}
	(\vec{X} - \vec{C}) \cdot \vec{V} = ||\vec{X} - \vec{C}||\cos{\theta}
	\label{eq:cone_form}
\end{equation}
В случае, если точка на луче принадлежит конусу будет получена система (\ref{eq:cyl_sys}).
\begin{equation}
	\begin{cases}
		\vec{P} = \vec{E} + t\vec{D} \\
		\frac{((\vec{P} - \vec{C}) \cdot \vec{V})^{2}}{(\vec{P} - \vec{C}) \cdot (\vec{P} - \vec{C})} = {\cos{\theta}}^{2}
	\end{cases}
	\label{eq:cyl_sys}
\end{equation}
После подстановки значения $P$ из системы (\ref{eq:cyl_sys}), в нижнее уравнение системы и упрощения полученного уравнения будет получено квадратное уравнение относительно $t$.
\begin{equation}
	\begin{cases}
	a = (\vec{D} \cdot \vec{V})^{2} - cos(\theta)^{2} \\
	b = 2 \cdot ((\vec{D} \cdot \vec{V}) \cdot ((\vec{E} - \vec{C}) \cdot \vec{V}) - \vec{D} \cdot (\vec{E} - \vec{C}){\cos{\theta}}^{2}) \\
	
	c = ((\vec{E} - \vec{C}) \cdot \vec{V})^{2} - \vec{C}\vec{E} \cdot \vec{C}\vec{E}\cos{\theta}^{2}
	\end{cases}
\end{equation}
После подстановки данных значений в выражение~(\ref{eq:sphere_solved}), будет получены значения $t$ \cite{cone_inter}.



\section{Анализ моделей отражения}
\label{sec:reflection_models}
Свет отраженный от объекта может быть диффузным и зеркальным.
Диффузное отражение происходит, когда свет поглощается поверхностью, а затем вновь испускается, в данном случае
отражение равномерно рассеивается по всем направлениям и положение наблюдателя не имеет значения. Зеркальное отражение
происходит от внешней поверхности объекта, оно является направленным и зависит от положения наблюдателя.
Так как отражение происходит от внешней части объекта, то отраженный свет сохраняет свойства падающего, например в случае если белый свет отражается
от красного тела, отраженный свет также будет нести в себе часть красного цвета.
Для расчета интенсивности света данных отражений существует несколько моделей \cite{Rodgers}:
\begin{enumerate}
	\item модель Ламберта;
	\item модель Фонга.
\end{enumerate}

\subsection{Модель Ламберта}
В данной модели рассматривается диффузная составляющая отражения.


\includeimage
{lambert_model} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Модель Ламберта} % Подпись рисунка



Считается, что интенсивность отраженного света
пропорциональна косинусу угла между направлением света и нормалью к поверхности:
\begin{equation} 
	I = k_aI_a + I_lk_l\cos\theta \quad 0 \leq \theta \leq \pi/2.
	\label{eq:lambert_model}
\end{equation}

В  формуле~(\ref{eq:lambert_model}):
\begin{enumerate}
	\item $k_a,k_d$ - коэффициенты рассеянного, диффузного отражения соответственно;
	\item $I_a,I_l$ - интенсивность рассеянного и диффузного отражения;
	\item $\theta$ - угол между нормалью к поверхности и направлением света.
\end{enumerate}
Заметим что значения приведенных коэффициентов лежат на отрезке от 0 до 1 \cite{Rodgers}.

Однако интенсивность света должна убывать с увеличением расстояния от источника до объекта, эмпирически было выведено следующее соотношение:
\begin{equation} 
	I = k_aI_a + \frac{I_lk_l\cos\theta}{d + K}.
	\label{eq:lambert_model_space}
\end{equation}
В данном случае добавлены $d,K$, в случае если точка наблюдения на бесконечности, то $d$ - определяется положением объекта,
ближайшего к точке наблюдения, то есть он будет освещаться с максимальной интенсивностью источника, а дальние объекты - с уменьшенной.
Таким образом $K$ - произвольная постоянная \cite{Rodgers}.


\subsection{Модель Фонга}
Данная модель также учитывает зеркальную составляющую отражения


\includeimage
{phong_model} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Модель Фонга} % Подпись рисунка



Зеркальная составляющая отражения имеет следующий вид:
\begin{equation} 
	I_s = I_l\omega(i,\lambda)\cos^n \alpha.
	\label{eq:phong_model}
\end{equation}

В формуле~(\ref{eq:phong_model}) символы соответственно означают:
\begin{enumerate} 
	\item $\omega(i,\lambda)$ - кривая отражения, показывающая отношение зеркально отраженного света к падающему, как функцию угла падения $i$ и длинны волны $\lambda$;
	\item $\alpha$ - угол между отраженным лучом и вектором, проведенным из точки падения луча в точку наблюдения;
	\item $n$ - степень, аппроксимирующая пространственное распределение отраженного света;
	\item $I_l$ - интенсивность падающего луча.
\end{enumerate}
Функция $\omega(i,\lambda)$ сложна, так что ее заменяют константой $k_s$, получаемой экспериментально \cite{Rodgers}.


Таким образом формула принимает следующий вид:
\begin{equation} 
	I = k_aI_a + k_dI_{l}(\hat{n} \cdot \hat{L}) + k_s  I_{l}(\hat{S} \cdot \hat{R})^n.
\end{equation}
В данном случае косинусы вычисляются с помощью скалярного произведения нормированных векторов:
\begin{enumerate}
	\item $\hat{n}$ - вектор нормали поверхности в точке падения;
	\item $\hat{L}$ - вектор падающего луча;
	\item $\hat{S}$ - вектор наблюдения;
	\item $\hat{R}$ - вектор отражения.
\end{enumerate}
Символ $\hat{}$ означает, что данный вектор нормированный \cite{Rodgers}.




\subsection{Выбор модели отражения}

Заметим, что глобальная модель в случае алгоритма Уиттеда освещения использует идею модели Фонга (см.~\ref{eq:intensivity}).






\section{Анализ алгоритмов визуализации}




При построении реалистичного изображения необходимо с полированными поверхностями необходимо визуализировать отражения света от тел.
Существуют множество подходов для создания реалистичных изображений:
\begin{enumerate}
	\item трассировка световых лучей (англ. Ray tracing);
	\item трассировка пути (англ. Path  tracing);
	\item трассировка лучей в пространстве изображения (англ. Screen reflections).
\end{enumerate}





\subsection{Алгоритм трассировки лучей}
\label{sec:ray_tracing}
В реальной жизни объекты являются видимыми, в случае если они отражают свет от источника, после чего данные лучи света попадают в человеческий глаз. Аналогичная идея заложена в данном способе создания изображения - необходимо отследить движение лучей света.
Отслеживать путь всех лучей света не стоит, так как это неэффективно, при построении изображения внимание следует уделять объектам видимыми со стороны наблюдателя.
В таком случае можно отслеживать лучи света, исходящие из точки наблюдения, т.~е. производить трассировку лучей в обратном направлении. В данном случае лучи стоит проводить через центры пикселей изображения,
считается, что наблюдатель находится на бесконечности, из-за чего все лучи параллельны оси OZ \cite{Rodgers,modern_ray_tracing}.




\includeimage
{ray_tracing} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.7\textwidth} % Ширина рисунка
{Пример трассировки луча} % Подпись рисунка






Первые работы принадлежат Уиттеду и Кэю. Алгоритм Уиттеда более общий и часто используется.
Уиттед пользуется моделью, в которой диффузная и зеркальная составляющие отражения рассчитываются подобно локальной модели (пример приведен на картинке \ref{sec:reflection_models}) \cite{Rodgers}.



\includeimage
{global_reflections} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Расчет зеркального отражения луча в алгоритме Уиттеда} % Подпись рисунка


На рисунке~\ref{img:global_reflections} луч \textbf{V} падает на поверхность в точку \textbf{Q}, после чего отражается в направлении \textbf{r} и преломляется
в направлении \textbf{p}.
В данном случае:
\begin{enumerate}
	\item $I_t$ - интенсивность света, проходящего по преломленному лучу \textbf{p};
	\item $\eta$ - показатели преломления сред (влияют на направление преломленного луча);
	\item $\hat{S},\hat{R}$ - полученные вектора наблюдения и отражения;
	\item $\hat{L_j}$ - Вектор к источнику света $j$.

\end{enumerate}

Тогда наблюдаемая интенсивность \textbf{I} выражается формулой:
\begin{equation} 
	I = k_aI_a + k_d \sum_{j} I_{l_j}(\hat{n} \cdot \hat{L_j}) + k_s \sum_{j} I_{l_j}(\hat{S} \cdot \hat{R_j})^n + k_sI_s + k_tI_t.
	\label{eq:intensivity}
\end{equation}

В формуле~(\ref{eq:intensivity}) соответственно означают:
\begin{enumerate}
	\item $k_a,k_d,k_s$ - коэффициенты рассеянного, диффузного, зеркального отражения соответственно;
	\item $k_t$ - коэффициент пропускания;
	\item $n$ - степень пространственного распределения Фонга;
\end{enumerate}
В данном случае знак $ \hat{} $  означает что данный вектор нормализован.
Значения коэффициентов определяются внешней средой, свойствами материала объектов и длинной волн света
Таким образом возможно посчитать интенсивность света для отраженной и преломленной части луча.
После чего полученные вычисления необходимо выполнить еще раз для отраженного и преломленного луча и т.~д., а также сложить полученные интенсивности.
Теоретически свет может отражаться бесконечно, так что стоит ограничить число рассматриваемых отражений либо определенным числом,
либо не рассматривать лучи с интенсивностью меньше определенного значения
Таким образом данный алгоритм имеет асимптотику $O(N \cdot C \cdot 2^{K})$, где \textbf{N} - количество тел,\textbf{C} - количество испускаемых лучей,
\textbf{K} - количество рассматриваемых отражений света. \cite{Rodgers}



\textbf{Достоинства алгоритма}:
\begin{enumerate}
	\item создание реалистичных изображений. \cite{Rodgers,modern_ray_tracing,SSR};
	\item возможность наблюдения физических явлений, так как алгоритм симулирует поведение света в реальной жизни \cite{Rodgers,modern_ray_tracing,SSR}.
\end{enumerate}


\textbf{Недостатки алгоритма}:
\begin{enumerate}
	\item долгое время время получения кадра. \cite{Rodgers,modern_ray_tracing,SSR};
	\item количество требуемой памяти, так как в памяти необходимо хранить все отраженные и преломленные лучи, полученные при предыдущих расчетах \cite{Rodgers,modern_ray_tracing,SSR}.
\end{enumerate}


\subsection{Трассировка лучей в пространстве изображения}
\textbf{Основная идея алгоритма - симуляция физического процесса прохождения света, рассматривая только видимые объекты.} \par
Обычно при необходимости расчета отражений и теней уже известны объекты, которые находятся на сцене. При использовании алгоритма трассировки лучей в пространстве изображения (англ. Screen-space reflections, SSR), используется информация о имеющихся
объектов из-за чего трудозатраты на создание изображения заметно сокращаются.
Асимптотическая оценка данного алгоритма аналогична асимптотической оценке алгоритма трассировке лучей, однако в данном случае будут анализироваться только видимые объекты.\cite{SSR}

Перед началом алгоритма требуется информация для каждого пикселя:
\begin{enumerate}
	\item Координата Z наиближайшей к наблюдателю поверхности.
	\item Нормаль данной поверхности.
\end{enumerate}



\includeimage
{SSR_data_flow} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.6\textwidth} % Ширина рисунка
{Поток данных при использовании SSR} % Подпись рисунка



До начала работы самого алгоритма необходимо подготовить данные, что происходит в два этапа:
\begin{enumerate}
	\item Геометрический проход (англ. Geometry pass).
	\item Световой проход (англ. Lightning pass).
\end{enumerate}

На картинке~\ref{img:SSR_data_flow} используется понятие \textbf{G-buffer}, этот буфер содержит все необходимые данные для начала работы алгоритма, данные для данного буфера
будут получены после геометрического прохода. В общем случае он содержит для каждого пикселя:
\begin{enumerate}
	\item Нормали к видимым поверхностям.
	\item Значение z наиближайшей видимой фигуры.
	\item Свойства материалов, значимые для трассировки света (коэффициенты диффузного и зеркального отражения).
\end{enumerate}
При световом проходе для каждого пикселя выбираются источники, которые влияют на его интенсивность
Работа SSR аналогична работе алгоритма \textbf{Ray tracing}, однако информация о видимых объектах уже получена и будут рассматриваться только они.
Из-за этого, если часть объекта не видима то изображение будет не корректным, как, например, на картинке~\ref{img:SSR_fail}~\cite{SSR,reflexion_types}.


\includeimage
{SSR_fail} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.7\textwidth} % Ширина рисунка
{Некорректный расчет отражений при использовании SSR} % Подпись рисунка



\textbf{Достоинства алгоритма}:
\begin{enumerate}
	\item меньшее время получения кадра, чем при использовании алгоритма трассировки лучей \cite{SSR}.
\end{enumerate}

\textbf{Недостатки алгоритма}:
\begin{enumerate}
	\item При наличии невидимых для наблюдателя частей объектов в отражении изображение будет некорректным \cite{SSR};
	\item Искажение геометрии при генерации изображений. \cite{SSR}
\end{enumerate}

\subsection{Трассировка пути}
В обратной трассировки лучей считается, что отражение луча идеально,  и через каждый пиксель экрана трассируется один луч, однако ввиду данных допущений
изображения не являются полностью физически корректными \cite{ray_path_tracing}.
Данный алгоритм вычисляет интенсивность освещенности с помощью метода Монте-Карло, так как отражения лучей имеют случайный характер \cite{monte_carlo}.
Для реализации метода Монте Карло  для каждого пикселя генерируется несколько  лучей,
после чего результирующее значение их интенсивностей усредняется \cite{path_tracing_def}.

Каждый раз, когда луч пересекается с поверхностью, выпускается теневой и случайный отраженный луч.
Теневой луч --- луч, с помощью которого учитывается прямое освещение (свет излучаемый источником света) для данной точки выборки. Данный луч проводится из 
точки пересечения к объекту, являющимся источником света в данной сцене. В случае если данный луч пересекает объект сцены, то в данной точке интенсивность
прямого света равна 0. Однако в таком случае объект может получить свет от других объектов сцены с помощью отраженных лучей (непрямое освещение) при пересечении трассируемого луча
с объектами, в случае если  точка пересечения освещена прямым освещением, интенсивность данного освещения будет учитываться при расчете интенсивности света исходного луча.
Таким обрзом при каждом столкновении луча с примитивом учитывается прямое и непрямое освещение, которое будет учитываться при расчете интенсивности отраженного луча.
Из-за того что направление лучей рассчитывается случайно, при малом количестве генерируемых лучей на пиксель лучи не пересекут исходные объекты, что образует шумы, которые 
представлены на картинке \ref{img:noise_path_tracing} \cite{path_tracing, ray_path_tracing}. Для избежания шумов необходимо увеличить число генерируемых лучей на 1 пиксель.
Из-за необходимости в генерации большого количества лучей данный алгоритм трудозатратнее предыдущих и не позволяет наблюдать сцену в реально времени из-за шумов \cite{path_tracing}.
Трассировка пути позволяет получить более реалистичное изображение, на картинках \ref{img:ray_trace_cmp} и \ref{img:path_trace_cmp} представлены два изображения,
полученные с помощью трассировки лучей и трассировки пусти соответственно \cite{cyber_trce}.




\includeimage
{noise_path_tracing} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Пример шума при использовании трассировки пути} % Подпись рисунка



\includeimage
{ray_trace_cmp} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Пример кадра комнаты в игре Cyberpunk 2077 с помощью трассировки лучей} % Подпись рисунка

\includeimage
{path_trace_cmp} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Пример кадра комнаты в игре Cyberpunk 2077 с помощью трассировки пути} % Подпись рисунка







\subsection{Выбор оптимального алгоритма}




В таблице \ref{t:trace_cmp} приведено сравнение рассмотренных алгоритмов получения кадра. Цифры в строках таблицы показывают позицию соответствующего 
алгоритма по данному критерию, при сортировке по возрастанию. 

Наиболее трудоемким алгоритмом является алгоритм трассировки пути, так как необходимо
генерировать несколько лучей на каждый пиксель экрана и агрегировать результаты вычислений,  трассировка лучей в пространстве изображения (SSR), 
анализирует только видимые с точки зрения наблюдателя объекты, что позволяет совершать меньше операций чем в обратной трассировке лучей~\cite{path_tracing_comp,SSR,modern_ray_tracing}.

\begin{table}[ht]
	\centering
	\caption{Сравнение различных алгоритмов визуализации объектов}
\begin{tabular}{|l|c|c|c|}
	\hline
	\diagbox[width=15em]{Критерии сравнения}{Алгоритм}&  Ray tracing & SSR & Path tracing \\ \hline
	Время получения кадра2 & 2 & 1 & 3 \\ \hline
	Реалистичность моделирования & 2 & 1 & 3 \\ \hline
	Наличие шумов & нет & нет & да \\ \hline
	
\end{tabular}
\label{t:trace_cmp}
\end{table}


Трассировка пути позволяет моделировать случайное отражение света, иные алгоритмы в общем случае рассматривают идеальное отражение луча,
трассировка лучей в пространстве изображения анализирует отражения от  объектов видимых только наблюдателю из-за чего отражения не всегда получаются правдоподобными~\cite{SSR,path_tracing}.

Из-за случайности генерируемых лучей при трассировке пути возможно появление шумов, в иных алгоритмов рассматривается только 1 луч, так что они лишены данной проблемы~\cite{path_tracing}.




При реализации отражений примитивов точность их представления играет важную роль, однако необходимо учитывать возможность генерации правдоподобных отражений
в реальном мире. Трассировка пути позволяет получать наиболее реалистичные кадры, однако данный алгоритм требует больших затрат на удаление шума, что
не позволяет его использовать в реально времени, трассировка лучей в пространстве изображения демонстрирует нереалистичные кадры при 
отсутствии объекта в области видимости наблюдателя. Таким образом наилучшим алгоритмом дял поставленной задачи является алгоритм обратной трассировки лучей.


\textbf{Выводы}

В данном разделе были проанализированы модели отражения и алгоритмы создания отражений.
Таким образом были выбраны:
\begin{enumerate}
	\item \textbf{Алгоритм создания отражений} - Алгоритм обратной трассировки лучей.
	\item \textbf{Модель отражения} - Модель отражения Фонга.
\end{enumerate}


Входными данными для полученной системы будут являться:
\begin{enumerate}
	\item Интенсивность источника.
	\item Спектральные характеристики материала примитива.
	\item Положение источника.
	\item Положение примитива.
	\item Угол поворота примитива.
\end{enumerate}